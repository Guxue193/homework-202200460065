 实验报告：SM4分组密码算法的实现与验证

 一、实验目的
- 深入理解GM/T 0002-2012《SM4分组密码算法》的核心原理与完整执行流程
- 掌握ECB工作模式的关键实现细节（包括分组长度处理、数据填充机制及边界对齐方法）
- 利用官方测试向量验证算法实现的正确性与稳定性
- 在C++开发环境中完成"算法重写-代码实现-功能验证"的全流程实践，提升密码算法工程化实现能力

 二、实验环境配置
- 操作系统：Windows 10 配合WSL(Windows Subsystem for Linux)
- 编译工具：g++ 11.4 或 clang++ 16，采用C++17标准
- 构建系统：CMake 3.22
- 开发工具：CLion集成开发环境
- 依赖库：仅使用C++标准库（包括`<vector>`、`<cstdint>`、`<stdexcept>`、`<iostream>`、`<iomanip>`等）

 三、SM4算法原理概述
SM4算法是一种迭代型分组密码，主要技术参数与组件如下：

- 基础参数：
  - 分组长度：128比特（16字节）
  - 密钥长度：128比特（16字节）
  - 迭代轮数：32轮Feistel结构

- 核心组件：
  - S盒：8比特输入到8比特输出的非线性置换，包含256个预定义常量
  - 线性变换：包括L变换和L'变换，通过异或与循环左移组合实现32比特数据变换
  - 轮密钥扩展：基于原始密钥、系统参数FK及固定参数CK生成32组32比特轮密钥

- ECB工作模式：
  采用分组独立加解密方式，无需初始向量(IV)，本实验中强制要求输入数据长度为16字节的整数倍，暂不涉及填充处理

 四、代码结构设计

 文件组成
- `include/SM4.h`：定义对外接口、常量及类声明
- `src/SM4.cpp`：实现SM4算法的核心逻辑
- `main.cpp`：包含测试向量验证程序，用于算法正确性检验

 类结构设计
- 构造函数：在对象初始化阶段完成密钥扩展过程，将生成的32组轮密钥存储在`roundKey[32]`数组中
- 公开接口：
  - `encrypt()`：按ECB模式对符合长度要求的数据进行加密
  - `decrypt()`：按ECB模式对加密数据进行解密
- 私有工具函数：
  - `cryptCore()`：加密与解密的共用处理流程，通过布尔参数控制轮密钥使用顺序
  - `expandKey()`：依据GM/T 0002-2012第5.3节规定实现密钥扩展
  - 辅助函数：`roundFunc`、`nonLinear`、`linearL`、`linearLK`、`rotl`等，分别对应标准中定义的F函数、T变换、T'变换等操作

 五、编译与运行说明
1. 建立项目目录结构：
   ```
   sm4_project/
   ├── include/
   │   └── SM4.h
   ├── src/
   │   └── SM4.cpp
   ├── main.cpp
   └── CMakeLists.txt
   ```

2. 编写CMakeLists.txt配置文件，指定C++17标准及编译选项

3. 执行编译命令：
   ```bash
   mkdir build && cd build
   cmake ..
   make
   ```

4. 运行生成的可执行文件：
   ```bash
   ./sm4_test
   ```

 六、实验结果验证
程序运行后，输出结果与GM/T 0002-2012附录A中的官方测试向量完全匹配：

- 加密测试：使用标准测试密钥对指定明文进行加密，得到的密文与标准结果逐字节一致
- 解密测试：对标准密文进行解密操作，能够准确还原出原始明文
- 边界测试：当输入数据长度不为16字节倍数时，程序能正确抛出异常

 七、结果分析
- 算法实现的加密结果与标准值完全吻合，验证了轮函数、S盒变换及密钥扩展等核心模块的正确性
- 解密过程能够准确还原原始数据，证明加解密流程的对称性设计正确
- 程序对不符合长度要求的输入进行严格校验并抛出异常，符合ECB模式的设计规范
- 仅依赖C++17标准库实现，避免了第三方密码库的依赖，增强了代码的跨平台移植能力

 八、关键实现要点与问题记录
1. 字节序处理：
   采用大端字节序打包4×32比特字，与标准描述保持一致。在x86小端架构下，通过显式移位操作构造数据，避免了平台移植性问题。

2. 数据变换处理：
   32轮迭代结束后必须执行(X₀,X₁,X₂,X₃)到(X₃,X₂,X₁,X₀)的交换操作，该步骤若遗漏会导致测试失败。

3. 轮密钥使用：
   解密过程中必须使用逆序的轮密钥（即roundKey[31-r]），与加密过程的轮密钥使用顺序相反，否则会得到错误结果。

4. S盒实现：
   直接采用标准附录中定义的S盒常量，在编译期完成初始化，保证了constexpr特性和执行效率。

5. 异常处理：
   当输入密钥长度不符合要求时，构造函数会直接抛出异常，防止对象处于半初始化的不安全状态。

 九、扩展应用思考
1. 填充机制扩展：
   可添加PKCS7填充方案，使算法支持任意长度输入，并扩展std::string和std::span接口以提升易用性。

2. 工作模式扩展：
   在现有基础上可实现CBC、CFB、OFB、CTR、GCM等多种工作模式，建议采用std::array<uint8_t,16>作为初始向量(IV)的标准类型。

3. 性能优化方向：
   - 大文件处理：将cryptCore内部循环改造为OpenMP多线程并行处理
   - 查表优化：预计算T表（4KB×4）可使运算速度提升约3倍，但会增加代码体积

4. 测试体系完善：
   引入GoogleTest框架编写全面的单元测试，包括边界测试、大量随机向量测试，并可与OpenSSL的SM4实现进行交叉验证。

 十、实验总结
本次实验基于GM/T 0002-2012标准，从零实现了SM4分组密码算法及ECB工作模式。通过官方测试向量的验证，证明了实现的正确性。代码采用现代C++风格设计，具备清晰的接口定义、完善的异常处理和规范的常量管理，达到了工程级可维护性要求。

实验过程加深了对分组密码设计原理的理解，特别是Feistel结构、密钥扩展和非线性变换等核心概念的实际应用。后续可围绕性能优化和工作模式扩展继续深入研究，进一步完善SM4算法的实现。