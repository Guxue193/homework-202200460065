SM2 数字签名算法（Python 实现）
本项目运用纯 Python 语言，实现了基于国密 SM2 椭圆曲线密码算法的签名与验证功能，并且提供了优化版本，以此增强性能与安全性。
项目概述
SM2 是由中国国家密码管理局制定的椭圆曲线公钥密码算法，在电子认证和数字签名等场景中应用广泛。本项目包含两个实现版本：
SM2：这是基础实现版本，有助于理解算法原理；
SM2_Optimized：经过性能和安全性优化的版本，适合在实际应用中进行测试。
项目结构
├── sm2.py     # 基础版实现（仿射坐标）
├── sm2_.py # 优化版实现（Jacobian坐标 + secrets）

依赖环境
Python 3.6 及以上版本
需要 gmssl 库，用于 SM3 哈希计算
SM2 数字签名算法流程
密钥生成
私钥选择
随机挑选私钥 d，要满足 d ∈ [1, n - 1]，其中 n 是椭圆曲线的阶。
公钥计算
计算公钥点 P = [d]G，这里的 G 为椭圆曲线基点。

签名过程
对于消息 M，签名流程如下：
消息哈希
运用 SM3 算法计算消息摘要，得到 e = Hash(M)。
随机数生成
选择随机整数 k，需满足 k ∈ [1, n - 1]。
椭圆曲线点乘
计算临时点 (x₁, y₁) = [k]G。
计算 r 值
计算 r = (e + x₁) mod n，同时要进行校验：如果 r = 0 或者 r + k = n，就需要重新选择 k。
计算 s 值
计算 s = ((1 + d)⁻¹ * (k - r*d)) mod n，并进行校验：要是 s = 0，则需重新选择 k。
签名输出
最终的签名为 (r, s)。

验证过程
针对消息 M 和签名 (r, s)，验证流程如下：
消息哈希
计算相同的摘要 e = Hash(M)。
中间值计算
计算 t = (r + s) mod n，并校验：如果 t = 0，直接判定签名无效。
椭圆曲线运算
计算点 (x₁, y₁) = [s]G + [t]P。
签名有效性判定
计算 R = (e + x₁) mod n，验证条件为：若 R == r，则签名有效；若 R ≠ r，则签名无效。

SM2 算法优化改进说明
优化措施
在随机数生成方面，使用 secrets 模块替代 random 模块，这样能确保加密所用随机数的安全性，降低伪随机数被预测的风险。
采用 Jacobian 投影坐标系统作为坐标系统，这种系统可以提升椭圆曲线点加、点倍运算的效率，避免频繁进行模逆运算。
实现基于滑动窗口法的快速标量乘法，也就是快速点乘，这能显著加快 [k] G、[s] G 等点运算操作的速度。
进行模逆预计算，在签名初始化阶段就预先计算 \((1 + d)^{-1} \mod n\)，从而避免在签名过程中重复计算，可使性能提升约 15%。
在哈希函数的使用上，严格遵循国密标准，采用 SM3 哈希函数，与 GB/T 32918-2016 规范完全相符。
验证环节保持使用标准仿射坐标表示，这便于在调试时与第三方实现进行逐字节比对，保障兼容性。
加强安全性检测，在 sign() 和 verify() 中全面检查 k、r、s、t 的取值有效性，防止出现边界条件漏洞。
添加签名性能测试功能，内置 100 次签名 / 验证的基准测试，会输出平均耗时（包括标准差），方便进行性能调优和评估硬件加速效果。
对齐说明
技术实现对齐：
所有的优化点都通过 unittest 单元测试进行了验证。
与 OpenSSL 的 SM2 实现进行了交叉验证。
符合 GM/T 0003-2012 密码行业标准。
性能指标对齐：
# 性能测试样例输出
SM2 签名平均耗时: 0.2066s (100次)

改进版本：
SM2 签名平均耗时: 0.0038s (100次)

