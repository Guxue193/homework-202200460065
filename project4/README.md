SM3 哈希算法的实现与优化探究
项目概况
本项目聚焦于完成国密算法中 SM3 哈希函数的完整 C++ 实现。SM3 作为中国国家密码管理局颁布的哈希标准（GM/T 0004-2012），在功能上和 SHA-256 有相似之处，但在算法结构以及常量参数方面存在显著差异。
SM3 的应用场景十分广泛，在数字签名、消息认证码（MAC）、哈希验证等众多安全领域都发挥着重要作用。

算法基本原理
SM3 的主要操作步骤有以下几个方面。首先是消息填充（Padding），这是对输入消息进行预处理的重要步骤。然后是消息扩展（Message Expansion），在这一步会生成 W [68] 和 W′[64]。接下来是压缩函数（Compression Function），其中涉及到 FF、GG、P0、P1 等运算。最后是输出摘要（Digest），其长度为 256 位（32 字节）。
在每轮运算中，会使用不同的常量 Tj，前 16 轮使用的是 0x79CC4519，其余轮次则使用 0x7A879D8A。

项目功能及优化措施
功能特点
该项目支持接收输入的字符串或者 uint8_t 字节数组来进行哈希计算。输出结果为 std::vector<uint8_t> 类型，并且还能转换为十六进制字符串。同时，项目包含官方提供的测试用例，可用于验证算法的正确性。
优化详情
在优化方面，采用了 std::array 来替代裸数组，以此提高安全性和代码的可读性。运用 constexpr 对常量参数在编译期进行处理，有助于提升性能。使用现代 C++ 语法，像结构化绑定、范围 for、static_cast 等。通过合理划分函数，让结构更加清晰，便于进行维护。而且，该实现具备可扩展性，可作为其他密码系统（如 SM2）的基础组成部分。

文件构成
├── SM3.cpp # 包含SM3算法的核心实现以及测试用例
├── SM3_.cpp # 经过优化后的SM3算法


编译与运行方式
该项目支持 C++11 及更高版本的编译器，例如 g++、clang++、MSVC 等。它不依赖外部库，也无需借助 CMake，直接进行编译即可。
结果展示
Input: "abc"
Output: 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
Expected: 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
Match: 1

Input: "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"
Output: debe9ff92275b8a138604889c18e5a4d6fdb70e5387e5765293dcba39c0c5732
Expected: debe9ff92275b8a138604889c18e5a4d6fdb70e5387e5765293dcba39c0c5732
Match: 1

Input: "HelloSM3"
Output: 36065686c1859012d3b504ecee7ae52e5f0fdf3089a0854811f613f77599a4cd
Expected: 36065686c1859012d3b504ecee7ae52e5f0fdf3089a0854811f613f77599a4cd
Match: 1

详细优化思路
在数据结构安全性方面，原始实现采用 uint32_t V [8] 这样的裸数组，优化后改用 std::array<uint32_t, 8> V，这样做增强了类型安全，支持 STL 接口，也更易于维护。
对于常量的表示方法，原始实现通过 #define 或者常量函数手写，优化后采用 constexpr size_t BLOCK_SIZE = 64 等方式，实现了编译期优化，减少了魔法数字的使用。
在内联函数的管理上，原始实现中函数未添加 static 或 constexpr 标注，优化后所有辅助函数都标注为 static 或 constexpr，便于编译器进行内联优化，降低了链接开销。
宏与函数的替换方面，原始实现没有相关处理，优化后用 constexpr T (j) 替代宏定义，避免了宏可能带来的副作用，提高了代码可读性。
类型转换的安全性上，原始实现使用 int b = bytes [i] 进行转换，优化后明确使用 static_cast 进行转换，减少了因隐式转换引发的错误，提升了安全性。
STL 语法的运用上，原始实现采用原始 for 循环加下标，优化后使用 range-based for 加 structured binding，更符合现代语法，代码更简洁，可读性更强。
异常的安全性方面，原始实现全部采用裸指针操作，优化后利用 std::vector 和 std::array 管理资源，降低了内存泄漏的风险，使代码更安全。
结构的组织方式上，原始实现中所有函数堆砌在一起，较少进行私有封装，优化后结构清晰，对私有函数进行明确封装，方便了后期的维护和测试工作。
魔法数字的清理方面，原始代码中多处直接使用 64、32 等数字，优化后采用 BLOCK_SIZE、DIGEST_SIZE 等命名常量，提高了代码的可读性和灵活性。
输出的组织形式上，原始实现输出逻辑较为分散，优化后采用结构化输出，用表格展示测试结果，可读性更好，便于和测试数据进行对比。

